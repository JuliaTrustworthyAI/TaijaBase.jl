var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TaijaBase","category":"page"},{"location":"#TaijaBase","page":"Home","title":"TaijaBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TaijaBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [\n    TaijaBase,\n    TaijaBase.Samplers,\n]","category":"page"},{"location":"#TaijaBase.AbstractParallelizer","page":"Home","title":"TaijaBase.AbstractParallelizer","text":"An abstract type for parallelizers. This type is owned by the TaijaBase module to allow shipping it to packages that depend on TaijaBase, without having to depend on the TaijaParallel module. See also parallelize for a detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.parallelize-Tuple{Nothing, Function, Vararg{Any}}","page":"Home","title":"TaijaBase.parallelize","text":"parallelize(\n    parallelizer::nothing,\n    f::Function,\n    args...;\n    kwargs...,\n)\n\nIf no AbstractParallelizer has been supplied, just call or broadcast the function. \n\nNote for developers\n\nThis function is owned by the TaijaBase module to allow shipping it to packages that depend on TaijaBase, without having to depend on the TaijaParallel module. For example, in CounterfactualExplanations we rely on this function to parallelize the computation of counterfactual explanations. Unless the user explicitly provides a parallelizer, the function will just call the function f or broadcast it over the collection of arguments. There is no need to depend on TaijaParallel for this simple operation.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.AbstractSampler","page":"Home","title":"TaijaBase.Samplers.AbstractSampler","text":"Base type for samplers.\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.AbstractSampler-Tuple{Any, TaijaBase.Samplers.AbstractSamplingRule}","page":"Home","title":"TaijaBase.Samplers.AbstractSampler","text":"(sampler::AbstractSampler)(\n    model,\n    rule::AbstractSamplingRule;\n    niter::Int = 100,\n    clip_grads::Union{Nothing,AbstractFloat} = 1e-2,\n    n_samples::Union{Nothing,Int} = nothing,\n    kwargs...,\n)\n\nBase method for generating Monte Carlo samples for a given models, sampler and sampling rule.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.AbstractSamplingRule","page":"Home","title":"TaijaBase.Samplers.AbstractSamplingRule","text":"Base type for sampling rules.\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.ConditionalSampler","page":"Home","title":"TaijaBase.Samplers.ConditionalSampler","text":"ConditionalSampler <: AbstractSampler\n\nGenerates conditional samples: x sim p(xy)\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.ConditionalSampler-Tuple{Distributions.Distribution, Distributions.Distribution}","page":"Home","title":"TaijaBase.Samplers.ConditionalSampler","text":"ConditionalSampler(\n    𝒟x::Distribution, 𝒟y::Distribution;\n    input_size::Dims, batch_size::Int,\n    max_len::Int=10000, prob_buffer::AbstractFloat=0.95\n)\n\nOuter constructor for ConditionalSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.ImproperSGLD","page":"Home","title":"TaijaBase.Samplers.ImproperSGLD","text":"ImproperSGLD(α::Real=2.0, σ::Real=0.01)\n\nImproper SGLD optimizer.\n\nExamples\n\nopt = ImproperSGLD()\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.JointSampler","page":"Home","title":"TaijaBase.Samplers.JointSampler","text":"JointSampler <: AbstractSampler\n\nGenerates unconditional samples by drawing directly from joint distribution: x sim p(x y)\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.JointSampler-Tuple{Distributions.Distribution, Distributions.Distribution}","page":"Home","title":"TaijaBase.Samplers.JointSampler","text":"JointSampler(\n    𝒟x::Distribution, 𝒟y::Distribution, input_size::Dims, batch_size::Int;\n    max_len::Int=10000, prob_buffer::AbstractFloat=0.95\n)\n\nOuter constructor for JointSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.SGLD","page":"Home","title":"TaijaBase.Samplers.SGLD","text":"SGLD(a::Real=1.0, b::Real=1.0, γ::Real=0.5)\n\nStochastic Gradient Langevin Dynamics (SGLD) optimizer.\n\nExamples\n\nopt = SGLD()\nopt = SGLD(2.0, 100.0, 0.9)\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.UnconditionalSampler","page":"Home","title":"TaijaBase.Samplers.UnconditionalSampler","text":"UnonditionalSampler <: AbstractSampler\n\nGenerates unconditional samples: x sim p(x)\n\n\n\n\n\n","category":"type"},{"location":"#TaijaBase.Samplers.UnconditionalSampler-Tuple{Distributions.Distribution, Union{Nothing, Distributions.Distribution}}","page":"Home","title":"TaijaBase.Samplers.UnconditionalSampler","text":"UnconditionalSampler(\n    𝒟x::Distribution,\n    𝒟y::Union{Distribution,Nothing};\n    input_size::Dims,\n    batch_size::Int = 1,\n    max_len::Int = 10000,\n    prob_buffer::AbstractFloat = 0.95,\n)\n\nOuter constructor for UnonditionalSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.PCD-Tuple{TaijaBase.Samplers.AbstractSampler, Any, TaijaBase.Samplers.AbstractSamplingRule}","page":"Home","title":"TaijaBase.Samplers.PCD","text":"PCD(\n    sampler::AbstractSampler,\n    model,\n    rule::AbstractSamplingRule;\n    ntransitions::Int = 100,\n    niter::Int = 100,\n    kwargs...,\n)\n\nPersistent Contrastive Divergence (PCD) algorithm. This algorithm was originally proposed by Tieleman (2008) and is a variant of the Contrastive Divergence (CD) algorithm. The main difference is that PCD uses a persistent chain to estimate the negative phase of the gradient. This is done by keeping the state of the Markov chain between iterations. \n\nIn our context, the sampler is the persistent chain and the model is a supervised model. The sampler generates samples from the model's learned distribution. \n\nNote\n\nThis function does not perform any training. It only generates samples from the model. For training Joint Energy Models, see JointEnergyModels.jl.\n\nArguments\n\nsampler::AbstractSampler: The sampler to use.\nmodel: The model to sample from.\nrule::AbstractSamplingRule: The sampling rule to use.\nntransitions::Int=100: The number of transitions to perform.\nniter::Int=100: The number of iterations to perform.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nsampler.buffer: The buffer containing the samples generated by the sampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers._energy-Tuple{Any, Any, Int64}","page":"Home","title":"TaijaBase.Samplers._energy","text":"energy(f, x, y::Int; agg=mean)\n\nComputes the energy for conditional samples x sim p_theta(xy): E(x)=- f_theta(x)y.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers._energy-Tuple{Any, Any}","page":"Home","title":"TaijaBase.Samplers._energy","text":"energy(f, x)\n\nComputes the energy for unconditional samples x sim p_theta(x): E(x)=-textLogSumExp_y f_theta(x)y.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.energy-Tuple{TaijaBase.Samplers.ConditionalSampler, Any, Any, Any}","page":"Home","title":"TaijaBase.Samplers.energy","text":"energy(sampler::ConditionalSampler, model, x, y)\n\nEnergy function for ConditionalSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.energy-Tuple{TaijaBase.Samplers.JointSampler, Any, Any, Any}","page":"Home","title":"TaijaBase.Samplers.energy","text":"energy(sampler::JointSampler, model, x, y)\n\nEnergy function for JointSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.energy-Tuple{TaijaBase.Samplers.UnconditionalSampler, Any, Any, Any}","page":"Home","title":"TaijaBase.Samplers.energy","text":"energy(sampler::UnconditionalSampler, model, x, y)\n\nEnergy function for UnconditionalSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.mcmc_samples-Tuple{TaijaBase.Samplers.ConditionalSampler, Any, Optimisers.AbstractRule, AbstractArray}","page":"Home","title":"TaijaBase.Samplers.mcmc_samples","text":"mcmc_samples(\n    sampler::ConditionalSampler,\n    model,\n    rule::Optimisers.AbstractRule,\n    input_samples::AbstractArray;\n    niter::Int,\n    y::Union{Nothing,Int} = nothing,\n)\n\nSampling method for ConditionalSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.mcmc_samples-Tuple{TaijaBase.Samplers.JointSampler, Any, Optimisers.AbstractRule, AbstractArray}","page":"Home","title":"TaijaBase.Samplers.mcmc_samples","text":"mcmc_samples(\n    sampler::JointSampler,\n    model,\n    rule::Optimisers.AbstractRule,\n    input_samples::AbstractArray;\n    niter::Int,\n    y::Union{Nothing,Int} = nothing,\n)\n\nSampling method for JointSampler.\n\n\n\n\n\n","category":"method"},{"location":"#TaijaBase.Samplers.mcmc_samples-Tuple{TaijaBase.Samplers.UnconditionalSampler, Any, Optimisers.AbstractRule, AbstractArray}","page":"Home","title":"TaijaBase.Samplers.mcmc_samples","text":"mcmc_samples(\n    sampler::UnconditionalSampler,\n    model,\n    rule::Optimisers.AbstractRule,\n    input_samples::AbstractArray;\n    niter::Int,\n    y::Union{Nothing,Int} = nothing,\n)\n\nSampling method for UnconditionalSampler.\n\n\n\n\n\n","category":"method"}]
}
